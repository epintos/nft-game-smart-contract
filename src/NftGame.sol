// SPDX-License-Identifier: MIT

pragma solidity ^0.8.28;

import { ERC721 } from "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import { Base64 } from "@openzeppelin/contracts/utils/Base64.sol";
import { Strings } from "@openzeppelin/contracts/utils/Strings.sol";
import { VRFConsumerBaseV2Plus } from "@chainlink/contracts/src/v0.8/vrf/dev/VRFConsumerBaseV2Plus.sol";
import { VRFV2PlusClient } from "@chainlink/contracts/src/v0.8/vrf/dev/libraries/VRFV2PlusClient.sol";

/**
 * @title NFTGame
 * @author Esteban Pintos
 * @notice NFT contract where you can mint a character with some abilities and attack a boss. In every attack round,
 * the character and the boss will attack each other until one of them has no health points left.
 * The NFT metadata is encoded in base64 on chain. The imageURI is a link to an image that can be hosted in IPFS.
 * The attack damage is determined by a random number generated by the Chainlink VRF.
 */
contract NFTGame is ERC721, VRFConsumerBaseV2Plus {
    /// ERRORS ///
    error NFTGame__CharacterHasNoHpLeft();
    error NFTGame__BossHasNoHpLeft();
    error NFTGame_CantAttackIfNotOwner();

    /// TYPES ///
    using Strings for uint256;

    struct CharacterAttributes {
        uint256 characterIndex;
        string description;
        string name;
        string imageURI;
        uint256 currentHp;
        uint256 maxHp;
        uint256 attackDamage;
    }

    struct BossAttributes {
        string name;
        string description;
        string imageURI;
        uint256 currentHp;
        uint256 maxHp;
        uint256 attackDamage;
    }

    /// STATE VARIABLES ///
    uint256 private s_tokenCounter;
    mapping(uint256 => CharacterAttributes) private s_tokenIdCharacterAttributes;
    CharacterAttributes[] private s_characters;
    BossAttributes private s_boss;
    uint256 private immutable i_interval;
    bytes32 private immutable i_keyHash;
    uint256 private immutable i_subscriptionId;
    uint32 private immutable i_callbackGasLimit;
    uint16 private constant REQUEST_CONFIRMATIONS = 3;
    uint32 private constant NUMBER_OF_RANDOM_WORDS = 2;
    mapping(uint256 requestId => uint256 tokenId) private s_requestIdToTokenId;

    /// EVENTS ///
    event CharacterNftMinted(address indexed owner, uint256 indexed tokenId, uint256 indexed characterIndex);
    event AttackRoundComplete(uint256 indexed tokenId, uint256 indexed bossHpLeft, uint256 indexed characterHpLeft);
    event RequestedRandomAttackDamage(uint256 indexed requestId);

    /// FUNCTIONS ///

    // CONSTRUCTOR
    constructor(
        CharacterAttributes[] memory characters,
        BossAttributes memory boss,
        address vrfCoordinator,
        bytes32 gasLane,
        uint256 subscriptionId,
        uint32 callbackGasLimit
    )
        ERC721("NFTGame", "NFTG")
        VRFConsumerBaseV2Plus(vrfCoordinator)
    {
        s_boss = boss;
        for (uint256 i = 0; i < characters.length; i++) {
            CharacterAttributes memory character = CharacterAttributes({
                characterIndex: i,
                description: characters[i].description,
                name: characters[i].name,
                imageURI: characters[i].imageURI,
                currentHp: characters[i].currentHp,
                maxHp: characters[i].maxHp,
                attackDamage: characters[i].attackDamage
            });
            s_characters.push(character);
        }
        i_keyHash = gasLane;
        i_subscriptionId = subscriptionId;
        i_callbackGasLimit = callbackGasLimit;
    }

    // EXTERNAL FUNCTIONS
    function mintNft(uint256 characterIndex) external {
        _safeMint(msg.sender, s_tokenCounter);
        s_tokenIdCharacterAttributes[s_tokenCounter] = s_characters[characterIndex];
        emit CharacterNftMinted(msg.sender, s_tokenCounter, characterIndex);

        s_tokenCounter++;
    }

    /**
     * This function will request a random number to the Chainlink VRF to determine the attack damage
     * @param tokenId The tokenId of the character that will attack the boss.
     */
    function attack(uint256 tokenId) external {
        if (getApproved(tokenId) != msg.sender && ownerOf(tokenId) != msg.sender) {
            revert NFTGame_CantAttackIfNotOwner();
        }

        CharacterAttributes memory ownedCharacter = s_tokenIdCharacterAttributes[tokenId];
        if (ownedCharacter.currentHp == 0) {
            revert NFTGame__CharacterHasNoHpLeft();
        }

        if (s_boss.currentHp == 0) {
            revert NFTGame__BossHasNoHpLeft();
        }

        uint256 requestId = s_vrfCoordinator.requestRandomWords(
            VRFV2PlusClient.RandomWordsRequest({
                keyHash: i_keyHash,
                subId: i_subscriptionId,
                requestConfirmations: REQUEST_CONFIRMATIONS,
                callbackGasLimit: i_callbackGasLimit,
                numWords: NUMBER_OF_RANDOM_WORDS,
                extraArgs: VRFV2PlusClient._argsToBytes(VRFV2PlusClient.ExtraArgsV1({ nativePayment: false }))
            })
        );

        s_requestIdToTokenId[requestId] = tokenId;

        emit RequestedRandomAttackDamage(requestId);
    }

    // PRIVATE & INTERNAL VIEW FUNCTIONS
    /**
     * @notice This function is called by the Chainlink VRF when the random words are generated. The random words
     * are used to determine the character's and boss' real damage.
     * @param requestId The Chainlink requestId requested by the attack method.
     * @param randomWords The random words generated by the Chainlink VRF.
     */
    function fulfillRandomWords(uint256 requestId, uint256[] calldata randomWords) internal override {
        uint256 tokenId = s_requestIdToTokenId[requestId];
        CharacterAttributes memory character = s_tokenIdCharacterAttributes[tokenId];
        uint256 characterAttackDamage = randomWords[0] % character.attackDamage;
        uint256 bossAttackDamage = randomWords[1] % s_boss.attackDamage;

        if (character.currentHp < bossAttackDamage) {
            character.currentHp = 0;
        } else {
            character.currentHp -= bossAttackDamage;
        }

        if (s_boss.currentHp < characterAttackDamage) {
            s_boss.currentHp = 0;
        } else {
            s_boss.currentHp -= characterAttackDamage;
        }

        s_tokenIdCharacterAttributes[tokenId] = character;

        emit AttackRoundComplete(tokenId, s_boss.currentHp, character.currentHp);
    }

    function _baseURI() internal pure override returns (string memory) {
        return "data:application/json;base64,";
    }

    // PUBLIC & EXTERNAL VIEW FUNCTIONS
    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        CharacterAttributes memory chracterAttributes = s_tokenIdCharacterAttributes[tokenId];
        return string(
            abi.encodePacked(
                _baseURI(),
                Base64.encode(
                    abi.encodePacked(
                        '{"name": "',
                        chracterAttributes.name,
                        '", "description": "',
                        chracterAttributes.description,
                        '", "image": "',
                        chracterAttributes.imageURI,
                        '", "attributes": [ { "trait_type": "Health Points", "value": ',
                        chracterAttributes.currentHp.toString(),
                        '}, { "trait_type": "Max Health Points", "value": ',
                        chracterAttributes.maxHp.toString(),
                        '}, { "trait_type": "Attack Damage", "value": ',
                        chracterAttributes.attackDamage.toString(),
                        "} ]}"
                    )
                )
            )
        );
    }

    function getCharacters() public view returns (CharacterAttributes[] memory) {
        return s_characters;
    }

    function getBoss() public view returns (BossAttributes memory) {
        return s_boss;
    }

    function getMintedCharacterAttributes(uint256 tokenId) public view returns (CharacterAttributes memory) {
        return s_tokenIdCharacterAttributes[tokenId];
    }
}
